% rd1.m:  Front end for opening a data file.  RD1 does some basic% initialization and then prompts you for the file you wish to open.% Usage: rd%% Supported formats (as of March 2003): RTRV (.dat)     ACSII (.txt),%                                       ASD (.asd),     LabVIEW (.lab)%                                       Ober2 (.obr)    Raw Binary (.bin)% written by  Jonathan Jacobs%             September 1995 - March 2007  (last mod: 03/30/07)% modified by King Yi%             04/27/11  - Modified code to read in DS and TL input%                         channels that represent the digital stimulus output%                         and galvo laser on/off times.%function rd(~)function [data] = rd_cli_new(strFile)[strPath,strName,strExt] = fileparts(strFile);PATHNAME = [strPath filesep];FILENAME = [strName strExt];curdir=pwd;global  samp_freq %initedcurdir=pwd;%if ~exist('inited','var'), inited = 0; end%if ~inited%disp('initializing')%rdclear  % clear RD's variables%dataclr  % clear old data values%global2  % initialize the global data variablessetrootcd(matlabroot)cd(findomprefs)try   load enviroG.matcatch   beep   disp('Initializing OMtools environment variable.')   enviroendshowGraphs  = enviroG(1);  doLoadSacs  = enviroG(2);doScaling   = enviroG(3);  doRefix     = enviroG(4);doFiltering = enviroG(5);  doUnfolding = enviroG(6);doXTalkRmvl = enviroG(7);  doHeadAdj   = enviroG(8);debugme     = enviroG(9);  export      = enviroG(10);useTimeAxis = enviroG(11);omdir%a_files = 0; r_files = 0; b_files = 0;%o_files = 0; x_files = 0; l_files = 0;%max_len_l=0; max_len_r=0;rh=[]; lh=[]; rv=[]; lv=[]; rt=[]; lt=[];st=[]; sv=[]; ds=[]; tl=[]; hh=[]; hv=[];%inited = 1;try   cd( curdir )catch   disp('rd warning: the previous data source directory is missing.')end%endv=version;[comp, ~] = computer;switch comp(1)   case 'M'      if v(1)<= '5'         filefilter = '*.*';         sep = ':';         rdpath_flag = 1;      elseif v(1) >= '6'         filefilter={['*.lab;*.txt;*.bin;*.dat;*.obr;*.asd;*.mat;',...            '*.LAB;*.TXT;*.BIN;*.DAT;*.OBR;*.ASD;*.MAT;'],...            'lab, txt, bin, dat, obr, asd, mat' };         sep = '/';         rdpath_flag = 1;  %% was set to 0.  why?      end         otherwise      if v(1) == '4'         filefilter = ['*.dat *.txt *.mat *.obr *.asd *.lab *.bin'];      else         filefilter = {'*.dat;*.txt;*.mat;*.obr;*.asd;*.lab;*.bin'};         %filefilter = '*.*';      end      sep = '\';      rdpath_flag = 1;end% this moves us to the last directory from which we RD a file.% if anything goes wrong, we are unceremoniously dumped into the% root data directory.if rdpath_flag, rdpath('r'); end% [lh_rows, lh_col] = size(lh);  [rh_rows, rh_col] = size(rh);% [lv_rows, lv_col] = size(lv);  [rv_rows, rv_col] = size(rv);% [lt_rows, lt_col] = size(lt);  [rt_rows, rt_col] = size(rt);% [hh_rows, hh_col] = size(hh);  [hv_rows, hv_col] = size(hv);% [st_rows, st_col] = size(st);  [sv_rows, sv_col] = size(sv);% [ds_rows, ds_col] = size(ds);  [tl_rows, tl_col] = size(tl);% col = lh_col + rh_col + lv_col + rv_col + ...%       lt_col + rt_col + hh_col + hv_col + st_col + sv_col + ds_col + tl_col;% if col > 0 we have data in the hopper%if col > 0%    [nFiles, dummy] = size(namearray);%    if nFiles == 1, nfstr = ' file'; else nfstr = ' files'; end%    disp([num2str(nFiles) nfstr ' already loaded:'])%    numFullRows = fix(nFiles/5);%    inLastRow   = nFiles - (numFullRows*5);%    for i = 1:numFullRows%       disp( [namearray((i-1)*5+1,:) namearray((i-1)*5+2,:)...%              namearray((i-1)*5+3,:) namearray((i-1)*5+4,:)...%              namearray((i-1)*5+5,:)] )%    end%    remStr = [];%    for i = 1:inLastRow%       remStr = [remStr namearray(numFullRows*5 + i,:)];%    end%    disp( remStr )%    nFiles = nFiles + 1;% elsenFiles = 1;%end %if col...pause(0.5)% time to select a file to open% [filename, pathname] = uigetfile(filefilter, 'Load a data file');filename = FILENAME;pathname = PATHNAME;if filename == 0   % hit the "Cancel" button   disp( 'Canceled.');   rdclear   cd(curdir)   return;endfullpathname = [ pathname filename ];[shortname,exten] = strtok(filename,'.');exten = exten(2:end);% if isempty(what_f_array)%    what_f_array = filename;% enddisp( ' ' )disp( [ 'Loading ' filename] )% change to the directory where the data file is.% the '''' is a quoted quote.  this is necessary to allow for% cases where the pathname has a space in it.datapath = pathname(1:length(pathname)-1);try   cd(datapath)catch   setroot; datadirend% write the data file's path to 'rdpath.txt'rdpath('w', pwd);% it's file loading time!% do this if we are reading a .mat fileif strcmpi(exten, 'MAT')   disp('This is a saved workspace.')   disp('  Do you want to clear the present workspace before')   disp('  loading in this saved workspace (y/n)?')   yorn=lower(input('--> ','s'));   if yorn == 'y'      global temp      temp = filename;      filename = temp;      clear global temp   end   try      load(filename)   catch      disp('Could not loat the .mat file')   end   returnend% To properly scale the data, each individual "rd_" module calls 'getbias' and% 'applybias' before 'unfold'ing if needed (obsolete -- used for old ASL IR glasses)switch lower(exten)   case {'asd'}      fileformat = 'asyst';  rd_asd;   case {'bin'}      fileformat = 'rawbin'; rd_bin;   case {'dat'}      fileformat = 'retrieve'; rd_rtrv;   case {'lab'}      fileformat = 'labview'; rd_labv;   case {'obr'}      fileformat = 'ober2'; rd_ober2;   case {'txt'}      fileformat = 'ascii'; rd_ascii;   case {''}      disp('this file has no extension.  Please add the appropriate')      disp('three-letter type (e.g. ''.lab'', ''.obr'', ''.txt'', etc.)')      fileformat = 'unknown';      return   otherwise      disp('This is NOT an ASCII data file,') % Great Galloping Gonads, Batman!      disp('it''s is not a RETRIEVE file,')   % There's something TERRIBLY      disp('it''s is not an ober2 file,')        % wrong here.  Panic.      disp('it''s is not an LabVIEW file,')      disp('it''s is not a raw binary file,')      disp('and it''s is not an ASYST file.')      disp('Quite frankly, I''m stumped.  Please make sure that the')      disp('file name has a known three-letter extension at its end.')      fileformat = 'unknown';      returnend% 'rd_xxxx' returns adjusted data in 'newdata', channel names in 'chName'%chName=char(chName);dat_len = length(newdata);% remove any crosstalkif exist([shortname '.xt'],'file')   [xtfactors, xt_err_flag] = readxtalk(filename);      if ~xt_err_flag      newdata = removextalk(newdata, xtfactors, chName);   endend% update the lists (string and array) of file namesnamelist=filename;%namelist = upper([namelist, filename, ' ']);%namepad = blanks(13 - length(filename));%namearray = upper([namearray; filename, namepad]);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% we have loaded the data and done all offsetting/scaling.  Now% we need to add the data to the arrays, load the SCP data, plot% the whole mess and do any local shifting ('refix').% what eyes & directions are present?% [lh_rows, lh_col] = size(lh);  [rh_rows, rh_col] = size(rh);% [lv_rows, lv_col] = size(lv);  [rv_rows, rv_col] = size(rv);% [lt_rows, lt_col] = size(lt);  [rt_rows, rt_col] = size(rt);% [hh_rows, hh_col] = size(hh);  [hv_rows, hv_col] = size(hv);% [st_rows, st_col] = size(st);  [sv_rows, sv_col] = size(sv);% [ds_rows, ds_col] = size(ds);  [tl_rows, tl_col] = size(tl);%% col = lh_col + rh_col + lv_col + rv_col +...%       lt_col + rt_col + hh_col + hv_col + st_col + sv_col + ds_col + tl_col;% longestL = max( [lh_rows lv_rows lt_rows] );% longestR = max( [rh_rows rv_rows rt_rows] );%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Time to append the new data to the existing eye/direction arrays.% For safety's sake, to keep the has_XX arrays up to date, we% first make the newest entry a zero.  If there are actually% SCPs for this channel, the appropriate has_XX array entry% will then be set to one.% has_LH(total_files) = 0; has_RH(total_files) = 0;% has_LV(total_files) = 0; has_RV(total_files) = 0;% has_LT(total_files) = 0; has_RT(total_files) = 0;% has_HH(total_files) = 0; has_HV(total_files) = 0;% has_ST(total_files) = 0; has_SV(total_files) = 0;% has_DS(total_files) = 0; has_TL(total_files) = 0;% hasData(total_files,1:12) = zeros(1,12);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% oh, yeah, one more thing...  What do we do about head position?% we need to check for it and then decide whether to modify the% rh, lh, rv, lv data.  Should this be done before adding the data to% the arrays or not?  I suspect that the CORRECTED data should be added% which is what I've done here.% Ask rjl what he would like.  (12/13/96)% look for hh, hv data.  If it exists we need to decide whether or% not to modify the lh, rh, lv, rv data.HHadj = 0; HVadj = 0;if (doHeadAdj)   for xx = 1:dat_cols      if strcmpi(chName(xx,:), 'hh')         disp( ' ' )         disp('* Horizontal head coil data found.  Use it to')         disp('  correct the ''lh'', ''rh'' data? (y/n) ')         doHHeadCoil = input( '--> ', 's');         if lower(doHHeadCoil) == 'y'            HHadj = 1;            HHindex = xx;         end      elseif strcmpi(chName(xx,:), 'hv')         disp( ' ' )         disp('* Vertical head coil data found.  Use it to')         disp('  correct the ''lv'', ''rv'' data? (y/n) ')         doVHeadCoil = input( '--> ', 's');         if lower(doVHeadCoil) == 'y'            HVadj = 1;            HVindex = xx;         end      end   endend %if doHeadAdjdisp('')data = emData;data.start_times = 0;data.recmeth = rectype;data.comments = comments;data.samp_freq = samp_freq;data.numsamps = dat_len;% do any further post-processingif exist([shortname '.z'],'file')   if (doRefix), refix(filename); endendif exist([shortname '.f'],'file')   if (doFiltering), dofilt; endend% now we actually put the data into arrays and update some housekeeping.disp( 'Adding new data to array: ' )for xx = 1:dat_cols   col=1; total_files=1;   %col = col + 1;   %sampFreq(nFiles) = samp_freq(1);   %samp_freq = sampFreq(1);  % hopefully this is temporary.   switch lower(chName(xx,:))      case {'lh'}         %has_LH(total_files) = 1;         if (HHadj==1)            newdata(:,xx) = newdata(:,xx) - newdata(:, HHindex);         end         disp( [sprintf('\b'), ' lh'] )         lh = add_col( lh, newdata(:,xx), nFiles );          data.lh.data = lh;         %which_eye(col,:) = 'lh';               case {'rh'}         %has_RH(total_files) = 1;         if (HHadj==1)            newdata(:,xx) = newdata(:,xx) - newdata(:, HHindex);         end         disp( [sprintf('\b'), ' rh'] )         rh = add_col( rh, newdata(:,xx), nFiles );         data.rh.data = rh;         %which_eye(col,:) = 'rh';               case {'lv'}         %has_LV(total_files) = 1;         if (HVadj==1)            newdata(:,xx) = newdata(:,xx) - newdata(:, HVindex);         end         disp( [sprintf('\b'), ' lv'] )         lv = add_col( lv, newdata(:,xx), nFiles );         data.lv.data = lv;         %which_eye(col,:) = 'lv';               case {'rv'}         %has_RV(total_files) = 1;         if (HVadj==1)            newdata(:,xx) = newdata(:,xx) - newdata(:, HVindex);         end         disp( [sprintf('\b'), ' rv'] )         rv = add_col( rv, newdata(:,xx), nFiles );         data.rv.data = rv;         %which_eye(col,:) = 'rv';               case {'lt'}         %has_LT(total_files) = 1;         disp( [sprintf('\b'), ' lt'] )         lt = add_col( lt, newdata(:,xx), nFiles );         data.lt.data = lt;         %which_eye(col,:) = 'lt';               case {'rt'}         %has_RT(total_files) = 1;         disp( [sprintf('\b'), ' rt'] )         rt = add_col( rt, newdata(:,xx), nFiles );         data.rt.data = rt;         %which_eye(col,:) = 'rt';               case {'hh'}         %has_HH(total_files) = 1;         disp( [sprintf('\b'), ' hh'] )         hh = add_col( hh, newdata(:,xx), nFiles );         data.hh.data = hh;         %which_eye(col,:) = 'hh';               case {'hv'}         %has_HV(total_files) = 1;         disp( [sprintf('\b'), ' hv'] )         hv = add_col( hv, newdata(:,xx), nFiles );         data.hv.data = hv;         %which_eye(col,:) = 'hv';               case {'st'}         %has_ST(total_files) = 1;         disp( [sprintf('\b'), ' st'] )         st = add_col( st, newdata(:,xx), nFiles );         data.st.data = st;         %which_eye(col,:) = 'st';               case {'sv'}         %has_SV(total_files) = 1;         disp( [sprintf('\b'), ' sv'] )         sv = add_col( sv, newdata(:,xx), nFiles );         data.sv.data = sv;         %which_eye(col,:) = 'sv';               case {'ds'}         %has_DS(total_files) = 1;         disp( [sprintf('\b'), ' ds'] )         d_raw=[0.04 0.08 0.16 0.32 0.64 1.28 2.56]*10;         d_scaled=[15 10 5 0 -5 -10 -15];         ds=interp1(d_raw,d_scaled,ds,'linear','extrap');         ds = add_col( ds, newdata(:,xx), nFiles );         data.ds.data = ds;         %which_eye(col,:) = 'ds';      case {'tl'}         %has_TL(total_files) = 1;         disp( [sprintf('\b'), ' tl'] )         % Invert Galvo Laser on/off state (off = 0, on = 1)         tl=-tl+5;         tl = add_col( tl, newdata(:,xx), nFiles );         data.tl.data = tl;         %which_eye(col,:) = 'tl';              case {'var'}         %which_eye(col,:) = lower(chName(xx,:));         %eval( [lower(chName(xx,:)) ' = add_col( '...         %   lower(chName(xx,:)) ', newdata(:,xx), nFiles );'] );         disp(['Unknown channel: ' chName(xx,:) ])   end   end% Passive D/A Converter Lookup Table (See Hardware Documentation for more details)%  DS Vout (x10)   Deg %     0.4           15%     0.8           10%     1.6            5%     3.2            0%     6.4           -5%    12.8          -10%    25.6          -15% load the digital stimulus file if it appliesrd_dig;sname=lower(shortname);assignin('base', sname, data)% disp(' ')% disp(['The data have been added to the base workspace as the structure variable ' sname])% disp(['You can type "emd_extract(' sname ')" to access the individual channels.'])% yorn=input('Enter "y" to do that now: ','s');% if strcmpi(yorn,'y')%    %assignin('base', 'sname', sname)%    %evalin('base',['emd_extract(' sname ')'])%    emd_extract(data)% end%disp('Applying standard low-pass filtering and creating velocity arrays')%stdproc% clean up.if (~debugme)   %rdclearend